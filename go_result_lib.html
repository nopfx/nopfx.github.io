<html>
    <head>
        <title> How to handle errors in GO</title>
        <meta charset="UTF-8" />
<meta name="description" content="Notes on computherphile" />
<meta
    name="keywords"
    content="Notes, HTML, Rust, programming, code, go, golang, cyber, ctbersecurity"
/>
<meta name="author" content="Nop.F(x)" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
    href="https://fonts.googleapis.com/css2?family=Inika:wght@400;700&display=swap"
    rel="stylesheet"
/>

<link rel="stylesheet" href="assets/css/style.css" />
<script src="assets/js/script.js"></script>

    </head>
    <body>
        <div class="top-line">
    <div class="wrapper">
        <h1>
            <a href="index.html" class="top-line__logo">Nop.F(x) ~/Notes</a>
        </h1>
    </div>
</div>

        <div class="wrapper">
            <div class="terminal">
                <h1>Tiny Result Library in Go</h1>
<p>Go can sometimes be frustrating—especially when it comes to error handling. 2
Let me be clear: I love how simple and pragmatic Go is. But I also dislike how noisy and repetitive error handling can get. Writing <code>if err != nil { return err }</code> twenty times in a single function is not only boring—it also feels like programming in assembly when I signed up for a higher-level language.</p>
<p>So I wrote a <strong>Result[T]</strong> type. It’s small, generic, and gives me a taste of the expressive power you get in Rust. Below is how it works and why I think it’s a good (though not perfect) abstraction.</p>
<h2>Implementation</h2>
<pre><code class="language-go">package result

import "fmt"

type Result[T any] struct {
	val T
	err error
}

func From[T any](val T, err error) Result[T] {
	if err != nil {
		return Err[T](err)
	}
	return Ok(val)
}

func Ok[T any](val T) Result[T] {
	return Result[T]{val: val, err: nil}
}

func Err[T any](err error) Result[T] {
	var none T
	return Result[T]{val: none, err: err}
}

func (r Result[T]) IsErr() bool {
	return r.err != nil
}

func (r Result[T]) IsOk() bool {
	return r.err == nil
}

func (r Result[T]) Unwrap() T {
	if r.err != nil {
		panic(fmt.Sprintf("called Unwrap on Err: %v", r.err))
	}
	return r.val
}

func (r Result[T]) UnwrapOr(defaultVal T) T {
	if r.err != nil {
		return defaultVal
	}
	return r.val
}

func (r Result[T]) Map(f func(T) T) Result[T] {
	if r.err != nil {
		return r
	}
	return Ok(f(r.val))
}

func (r Result[T]) AndThen(f func(T) Result[T]) Result[T] {
	if r.err != nil {
		return r
	}
	return f(r.val)
}
</code></pre>
<h2>What’s Good About This?</h2>
<h3>Cleaner Chaining</h3>
<p>Instead of writing verbose error handling like this:</p>
<pre><code class="language-go">res, err := doThing()
if err != nil {
    return err
}
res2, err := doAnotherThing(res)
if err != nil {
    return err
}
</code></pre>
<p>You can express the same logic more concisely:</p>
<pre><code class="language-go">result.From(doThing()).
    AndThen(doAnotherThing).
    Unwrap()
</code></pre>
<p>This approach is more readable and declarative. It lets you focus on the data flow, not on boilerplate.</p>
<h3>Safety with Panic Option</h3>
<p>The <strong>Unwrap()</strong> method panics if the result contains an error, which is useful for quick scripts or test scenarios where you don’t want verbose error checks.<br />
If you want a fallback, there’s <strong>UnwrapOr()</strong>.</p>
<p>This duality is inspired by Rust’s <strong>Result</strong> type.</p>
<h3>Generic and Reusable</h3>
<p>By leveraging Go’s generics, this works with any type. You get all the benefits of type safety without needing type assertions or reflection tricks.</p>
<h3>Functional Flavor</h3>
<p><strong>Map()</strong> and <strong>AndThen()</strong> bring in a functional programming style.</p>
<ul>
<li><strong>Map()</strong> transforms the inner value.</li>
<li><strong>AndThen()</strong> chains more <strong>Result</strong> -producing functions.</li>
</ul>
<p>This makes it possible to write expressive pipelines without nested conditionals.</p>
<h2>Conclusion</h2>
<p>I built this Result library not to rewrite Go’s philosophy, but to work with it.
It’s a small abstraction that helps me write cleaner, more composable code—especially in projects where performance isn’t critical and developer happiness matters more.</p>
<p>If error handling in Go starts to feel like busywork, give it a try. Just remember: abstractions are tools, not rules. Use them where they help, and avoid them where they don’t.</p>
 
            </div>
        </div>
    </body>
</html>
