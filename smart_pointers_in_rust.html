<html>
    <head>
        <title> Smart Pointers in Rust</title>
        <meta charset="UTF-8" />
<meta name="description" content="Notes on computherphile" />
<meta
    name="keywords"
    content="Notes, HTML, Rust, programming, code, go, golang, cyber, ctbersecurity"
/>
<meta name="author" content="Nop.F(x)" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
    href="https://fonts.googleapis.com/css2?family=Inika:wght@400;700&display=swap"
    rel="stylesheet"
/>

<link rel="stylesheet" href="assets/css/style.css" />
<script src="assets/js/script.js"></script>

    </head>
    <body>
        <div class="top-line">
    <div class="wrapper">
        <h1>
            <a href="index.html" class="top-line__logo">Nop.F(x) ~/Notes</a>
        </h1>
    </div>
</div>

        <div class="wrapper">
            <div class="terminal">
                <h1>Rust Smart Pointers Explained</h1>
<p>Smart pointers in Rust provide additional functionality beyond regular references (<strong>&amp;T</strong>), such as <strong>heap allocation, reference counting, interior mutability, and thread safety</strong>.</p>
<h2>Box<T>: Heap Allocation and Ownership</h2>
<h3>What is Box<T>?</h3>
<ul>
<li>A smart pointer that <strong>allocates data on the heap</strong>.</li>
<li>Useful for <strong>large data structures</strong> or <strong>recursive types</strong>.</li>
<li>Has <strong>single ownership</strong> → Moves on assignment.</li>
</ul>
<h3>How to Use Box<T></h3>
<pre><code class="language-rust">fn main() {
    let x = Box::new(5); // `x` stores the heap-allocated value 5
    println!("x = {}", x);
}
</code></pre>
<p>Use Box<T> when:</p>
<ul>
<li>You need to <strong>store data on the heap</strong>.</li>
<li>You want to <strong>transfer ownership</strong> but still have Rust’s safety.</li>
<li>You need <strong>indirect recursion</strong> (because Rust needs to know the size at compile time).</li>
</ul>
<p>Don’t use <strong>Box<T></strong> when:</p>
<ul>
<li>A simple <strong>&amp;T</strong> reference is enough.</li>
<li>Performance overhead of heap allocation is unnecessary.</li>
</ul>
<h2>Rc<T>: Multiple Owners (Reference Counting)</h2>
<h3>What is <strong>Rc<T></strong>?</h3>
<ul>
<li>A <strong>reference-counted smart pointer</strong> that allows <strong>multiple owners</strong> of the same data.</li>
<li>Tracks <strong>how many references exist</strong> and deallocates memory when the last reference is dropped.</li>
<li><strong>Not thread-safe</strong> (use <strong>Arc<T></strong> for multi-threading).</li>
</ul>
<h3>How to Use <strong>Rc<T></strong></h3>
<pre><code class="language-rust">use std::rc::Rc;

fn main() {
    let a = Rc::new(10);
    let b = Rc::clone(&amp;a); // Increases reference count
    let c = Rc::clone(&amp;a);

    println!("Reference count: {}", Rc::strong_count(&amp;a)); // Prints: 3
}
</code></pre>
<p>Use <strong>Rc<T></strong> when:</p>
<ul>
<li>You need <strong>multiple owners</strong> for the same value (e.g., graph/tree structures).</li>
<li>You are <strong>not working with multiple threads</strong>.</li>
</ul>
<p>Don’t use Rc<T> when:</p>
<ul>
<li>You need <strong>thread safety</strong> (<strong>Rc<T></strong> is not thread-safe → use <strong>Arc<T></strong>).</li>
<li>You need <strong>mutable access</strong> (use <strong>RefCell<T></strong> instead).</li>
</ul>
<h2>Arc<T>: Thread-Safe Reference Counting</h2>
<h3>What is <strong>Arc<T></strong>?</h3>
<ul>
<li>A <strong>thread-safe version of Rc<T></strong> that allows <strong>shared ownership across threads</strong>.</li>
<li>Uses <strong>atomic reference counting</strong> instead of normal reference counting.</li>
<li>More expensive than <strong>Rc<T></strong> due to thread synchronization overhead.</li>
</ul>
<h3>How to Use <strong>Arc<T></strong></h3>
<pre><code class="language-rust">use std::sync::Arc;
use std::thread;

fn main() {
    let a = Arc::new(10);
    let b = Arc::clone(&amp;a);

    let handle = thread::spawn(move || {
        println!("Thread value: {}", b);
    });

    handle.join().unwrap();
}
</code></pre>
<p>Use <strong>Arc<T></strong> when:</p>
<ul>
<li>You need <strong>multiple owners across threads</strong>.</li>
<li>You are <strong>working in a multi-threaded environment</strong>.</li>
</ul>
<p>Don’t use Arc<T> when:</p>
<ul>
<li>You don’t need <strong>thread safety</strong> (<strong>Rc<T></strong> is more efficient in single-threaded code).</li>
<li>You need <strong>mutable access</strong> (use <strong>Mutex<T></strong> with <strong>Arc<T></strong> for that).</li>
</ul>
<h2>RefCell<T>: Interior Mutability (Runtime Borrow Checking)</h2>
<h3>What is <strong>RefCell<T></strong>?</h3>
<ul>
<li>Allows <strong>mutable access to data even when it’s immutable</strong>.</li>
<li>Unlike Rust’s usual borrowing rules (checked at compile time), <strong>RefCell<T></strong> enforces borrowing rules <strong>at runtime</strong>.</li>
<li>Useful when you need <strong>shared mutability in a single-threaded program</strong>.</li>
</ul>
<h3>How to Use <strong>RefCell<T></strong></h3>
<pre><code class="language-rust">use std::cell::RefCell;

fn main() {
    let a = RefCell::new(5);
    *a.borrow_mut() += 10;
    println!("Updated value: {}", a.borrow());
}
</code></pre>
<p>Use <strong>RefCell<T></strong> when:</p>
<ul>
<li>You need <strong>mutable access</strong> but Rust’s borrowing rules make it difficult.</li>
<li>You are <strong>working in a single-threaded environment</strong>.</li>
</ul>
<p>Don’t use <strong>RefCell<T></strong> when:</p>
<ul>
<li>You need <strong>compile-time borrowing safety</strong> (since <strong>RefCell<T></strong> allows runtime errors for borrowing violations).</li>
<li>You need <strong>thread safety</strong> (<strong>RefCell<T></strong> is <strong>not</strong> thread-safe → use <strong>Mutex<T></strong> instead).</li>
</ul>
<h2>Mutex<T>: Thread-Safe Interior Mutability</h2>
<h3>What is <code>Mutex&lt;T&gt;</code>?</h3>
<ul>
<li>A <strong>thread-safe way to enable interior mutability</strong>.</li>
<li>Ensures that only <strong>one thread</strong> can access the data at a time (prevents data races).</li>
<li>Requires <strong>locking/unlocking</strong> to access data.</li>
</ul>
<h3>How to Use <strong>Mutex<T></strong></h3>
<pre><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final count: {}", *counter.lock().unwrap());
}
</code></pre>
<p>Use <strong>Mutex<T></strong> when:</p>
<ul>
<li>You need <strong>mutable access across multiple threads</strong>.</li>
<li>You need <strong>safe concurrency management</strong>.</li>
</ul>
<p>Don’t use <strong>Mutex<T></strong> when:</p>
<ul>
<li>You <strong>don’t need thread safety</strong> (use <strong>RefCell<T></strong> in single-threaded cases).</li>
<li>You <strong>don’t want the overhead of locks</strong> (locks can cause performance bottlenecks).</li>
</ul>
<h2>Summary Table: Choosing the Right Smart Pointer</h2>
<table><thead><tr><th>Smart Pointer</th><th>Ownership</th><th>Thread-Safe?</th><th>Mutable Access?</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Box<T></td><td>Single</td><td>Yes</td><td>No</td><td>Heap allocation, recursive types</td></tr>
<tr><td>Rc<T></td><td>Multiple (reference counting)</td><td>No</td><td>No</td><td>Multiple owners in <strong>single-threaded</strong> programs</td></tr>
<tr><td>Arc<T></td><td>Multiple (atomic reference counting)</td><td>Yes</td><td>No</td><td>Multiple owners in <strong>multi-threaded</strong> programs</td></tr>
<tr><td>RefCell<T></td><td>Single</td><td>No</td><td>Yes (interior mutability)</td><td>Mutable access in <strong>single-threaded</strong> programs</td></tr>
<tr><td>Mutex<T></td><td>Single</td><td>Yes</td><td>Yes</td><td>Mutable access in <strong>multi-threaded</strong> programs</td></tr>
</tbody></table>
 
            </div>
        </div>
    </body>
</html>
