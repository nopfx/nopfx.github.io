<html>
    <head>
        <title> Ownership && lifetimes in Rust</title>
        <meta charset="UTF-8" />
<meta name="description" content="Notes on computherphile" />
<meta
    name="keywords"
    content="Notes, HTML, Rust, programming, code, go, golang, cyber, ctbersecurity"
/>
<meta name="author" content="Nop.F(x)" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
    href="https://fonts.googleapis.com/css2?family=Inika:wght@400;700&display=swap"
    rel="stylesheet"
/>

<link rel="stylesheet" href="assets/css/style.css" />
<script src="assets/js/script.js"></script>

    </head>
    <body>
        <div class="top-line">
    <div class="wrapper">
        <h1>
            <a href="index.html" class="top-line__logo">Nop.F(x) ~/Notes</a>
        </h1>
    </div>
</div>

        <div class="wrapper">
            <div class="terminal">
                <h1>Rust Ownership &amp; Lifetimes</h1>
<h2>What is Ownership?</h2>
<p>Rust does <strong>not</strong> have garbage collection. Instead, it has <strong>ownership rules</strong> to manage memory <strong>automatically</strong>.</p>
<h3>Rule #1: Every Value Has <strong>One</strong> Owner</h3>
<pre><code class="language-rust">fn main() {
    let banana = String::from("banana"); // banana owns this String
    let monkey = banana; // Ownership MOVED to monkey!
    // println!("{}", banana); // ERROR! banana lost ownership!
    println!("{}", monkey); // Works!
}
</code></pre>
<p>When <strong>banana</strong> gives ownership to <strong>monkey</strong>, it <strong>loses access</strong> to the value.</p>
<h3>Rule #2: When the Owner Dies, the Value is Dropped</h3>
<pre><code class="language-rust">fn main() {
    {
        let food = String::from("apple"); // food is created
        println!("Monkey eats: {}", food);
    } // food goes out of scope, and is DROPPED
    // println!("{}", food); // ERROR! food is gone!
}
</code></pre>
<p>When <strong>food</strong> goes <strong>out of scope</strong>, Rust <strong>automatically cleans it up</strong>.</p>
<h2>Borrowing</h2>
<p>Rust <strong>allows borrowing</strong> instead of moving ownership.</p>
<h3>Rule #3: You Can Borrow <strong>Without Taking Ownership</strong></h3>
<pre><code class="language-rust">fn eat(banana: &amp;String) { // Borrowing (not moving)
    println!("Monkey eats: {}", banana);
}

fn main() {
    let banana = String::from("banana");
    eat(&amp;banana); // Works! banana is still owned by main
    println!("Banana is still here: {}", banana);
}
</code></pre>
<p>Borrowing (<strong>&amp;</strong>) allows you to <strong>use</strong> a value <strong>without owning</strong> it.</p>
<h3>Rule #4: No Mutability Conflicts</h3>
<p>You can:</p>
<ol>
<li>Have <strong>multiple immutable</strong> references (readonly)</li>
</ol>
<pre><code class="language-rust">fn main() {
    let mut banana = String::from("banana");
    let monkey1 = &amp;banana; // Immutable borrow
    let monkey2 = &amp;banana; // Another immutable borrow
    println!("Monkeys see: {} and {}", monkey1, monkey2); // Works!

    // let monkey3 = &amp;mut banana; // ERROR! Can't mutate while others read!
}
</code></pre>
<ol start="2">
<li>OR <strong>only one mutable</strong> reference (write access)</li>
</ol>
<pre><code class="language-rust">fn main() {
    let mut banana = String::from("banana");
    let monkey = &amp;mut banana; // Allowed, only ONE mutable borrow
    monkey.push_str(" banana"); // Modify banana!
    println!("Monkey added more bananas: {}", monkey);
}
</code></pre>
<h2>Lifetimes</h2>
<p>Rust checks lifetimes to make sure values don’t disappear while being borrowed.</p>
<h3>Rule #5: Lifetimes Define <strong>How Long a Borrow is Valid</strong></h3>
<pre><code class="language-rust">fn longest&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len() { s1 } else { s2 }
}

fn main() {
    let banana = String::from("banana banana banana");
    let apple = String::from("apple");
    let best = longest(&amp;banana, &amp;apple);
    println!("Best fruit: {}", best);
}
</code></pre>
<p>Here, <strong>longest&lt;’a&gt;</strong> means <strong>both inputs and output share the same lifetime</strong>.</p>
<h3>What Happens When Lifetimes Are Wrong?</h3>
<pre><code class="language-rust">fn bad() -&gt; &amp;String { // ERROR! No lifetime!
    let banana = String::from("banana");
    &amp;banana // banana is dropped here!
}
</code></pre>
<p>The value <strong>disappears</strong> before it can be returned.</p>
<h2>Summary</h2>
<ul>
<li>Ownership <strong>moves</strong> when assigned to another variable.</li>
<li>Every value has <strong>one owner</strong>.</li>
<li><strong>Borrowing</strong> (<strong>&amp;</strong>) lets you use without owning.</li>
<li>Multiple <strong>immutable</strong> or <strong>one mutable</strong> borrow allowed.</li>
<li><strong>Lifetimes</strong> ensure borrowed values live long enough.</li>
</ul>
 
            </div>
        </div>
    </body>
</html>
