<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Nop.Fx(Notes) -> </title><link rel="stylesheet" href="assets/css/reset.css"><link rel="stylesheet" href="assets/css/main.css"><link rel="stylesheet" href="assets/css/terminal.css"><link rel="stylesheet" href="assets/css/responsive.css"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet"><link rel="stylesheet" href="assets/css/dark-mode.css"></head><body><div class="container"><header><div class="terminal-header"><div class="terminal-buttons"><span class="terminal-button close"></span><span class="terminal-button minimize"></span><span class="terminal-button maximize"></span></div><div class="terminal-title">~/</div><div class="toggle-container"><span class="toggle-label">Theme</span><label class="toggle-switch"><input type="checkbox" id="dark-mode-toggle"><span class="toggle-slider"></span></label></div></div><nav><ul class="terminal-nav"><li><a href="index.html">> home</a></li><li><a href="https://github.com/nopfx" target="_blank">> code</a></li><li><a href="https://discord.gg/CtP4vwG5" target="_blank">> chat</a></li></ul></nav></header><main><div class="note-content"><h1>ğŸ¦ Rust Ownership &amp; Lifetimes (For Monkeys!)</h1><h2>ğŸŒ What is Ownership? (Rustâ€™s Biggest Rule!)</h2><p>Rust does <strong>not</strong> have garbage collection. Instead, it has <strong>ownership rules</strong> to manage memory <strong>automatically</strong>!</p><h3>ğŸ¡ Rule #1: Every Value Has <strong>One</strong> Owner</h3><pre><code class="language-rust">fn main() {    let banana = String::from("ğŸŒ"); // banana owns this String    let monkey = banana; // Ownership MOVED to monkey!    // println!("{}", banana); // âŒ ERROR! banana lost ownership!    println!("{}", monkey); // âœ… Works!}</code></pre><p>When <code>banana</code> gives ownership to <code>monkey</code>, it <strong>loses access</strong> to the banana! ğŸµ</p><h3>ğŸ¡ Rule #2: When the Owner Dies, the Value is Dropped</h3><pre><code class="language-rust">fn main() {    {        let food = String::from("ğŸ"); // food is created        println!("Monkey eats: {}", food);    } // food goes out of scope, and is DROPPED ğŸ—‘ï¸    // println!("{}", food); // âŒ ERROR! food is GONE!}</code></pre><p>When <code>food</code> goes <strong>out of scope</strong>, Rust <strong>automatically cleans it up</strong>! ğŸ§¹</p><h2>ğŸ”„ Borrowing (Sharing Bananas!)</h2><p>Monkeys donâ€™t like sharing, but Rust <strong>allows borrowing</strong> instead of moving ownership!</p><h3>ğŸ¡ Rule #3: You Can Borrow <strong>Without Taking Ownership</strong></h3><pre><code class="language-rust">fn eat(banana: &amp;String) { // Borrowing (not moving)    println!("Monkey eats: {}", banana);}fn main() {    let banana = String::from("ğŸŒ");    eat(&amp;banana); // âœ… Works! banana is still owned by main    println!("Banana is still here: {}", banana);}</code></pre><p>Borrowing (<code>&amp;</code>) allows you to <strong>use</strong> a value <strong>without owning</strong> it!</p><h3>ğŸš« Rule #4: No Mutability Conflicts!</h3><p>You can:</p><ul><li><ol><li>Have <strong>multiple immutable</strong> references (readonly ğŸ§Š)</li></ol></li><li><ol start="2"><li>OR <strong>only one mutable</strong> reference (write access âœï¸)</li></ol></li></ul><pre><code class="language-rust">fn main() {    let mut banana = String::from("ğŸŒ");    let monkey1 = &amp;banana; // Immutable borrow    let monkey2 = &amp;banana; // Another immutable borrow    println!("Monkeys see: {} and {}", monkey1, monkey2); // âœ… Works!    // let monkey3 = &amp;mut banana; // âŒ ERROR! Can't mutate while others read!}</code></pre><pre><code class="language-rust">fn main() {    let mut banana = String::from("ğŸŒ");    let monkey = &amp;mut banana; // âœ… Allowed, only ONE mutable borrow    monkey.push_str("ğŸŒ"); // Modify banana!    println!("Monkey added more bananas: {}", monkey);}</code></pre><h2>â³ Lifetimes (How Long Can You Borrow?)</h2><p>Sometimes monkeys <strong>borrow bananas for too long</strong>! Rust checks lifetimes to make sure bananas donâ€™t disappear while being borrowed! ğŸŒâ³</p><h3>ğŸ¡ Rule #5: Lifetimes Define <strong>How Long a Borrow is Valid</strong></h3><pre><code class="language-rust">fn longest&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {    if s1.len() &gt; s2.len() { s1 } else { s2 }}fn main() {    let banana = String::from("ğŸŒğŸŒğŸŒ");    let apple = String::from("ğŸ");    let best = longest(&amp;banana, &amp;apple);    println!("Best fruit: {}", best);}</code></pre><p>Here, <code>longest&lt;'a&gt;</code> means <strong>both inputs and output share the same lifetime</strong>.</p><h3>âŒ What Happens When Lifetimes Are Wrong?</h3><pre><code class="language-rust">fn bad() -&gt; &amp;String { // âŒ ERROR! No lifetime!    let banana = String::from("ğŸŒ");    &amp;banana // âŒ banana is DROPPED here!}</code></pre><p>The banana <strong>disappears</strong> before it can be returned! ğŸš¨</p><h2>ğŸ Summary (Monkey Wisdom ğŸŒ)</h2><ul><li>âœ” Ownership <strong>moves</strong> when assigned to another variable â¡ï¸</li><li>âœ” Every value has <strong>one owner</strong> ğŸ¡</li><li>âœ” <strong>Borrowing</strong> (<code>&amp;</code>) lets you use without owning ğŸ”„</li><li>âœ” Multiple <strong>immutable</strong> or <strong>one mutable</strong> borrow allowed ğŸš¦</li><li>âœ” <strong>Lifetimes</strong> ensure borrowed values live long enough â³</li></ul><p>Now go write some Rust without dropping your bananas! ğŸµğŸš€</p></div></main><footer><div class="terminal-line"><span class="prompt">lazy@nop.f(x):~$</span><span class="command">uname -a</span></div><div class="terminal-output"><p>Â© 2025 Nop.F(x). All rights reserved.</p><p>Built with <span class="heart">â™¥</span> to VIM by using pure HTML/CSS.</p></div></footer></div><script src="assets/js/dark-mode.js"></script></body></html>